// 1.选择排序
/**
 * 步骤：
 * （1）选择一组数据中最小的元素，和未排序的数据中第一个元素进行交换
 *  (2) 重复上述过程
 * （3）直到最后一个元素，完成排序
 */


// 2.插入排序
/**
 * 步骤：
 * （1）将一组数据分为两组，一组为已经排好序的数据，另一组为未排好序的数据
 * （2）每次从未排好序的数据中取出一个，放入已经排好序的数据中，并放到适当的位置（排序）
 * （3）重复上述过程，直至未排好序的数据中的元素个数为0
 */

function swap(a,b){
    let temp
    temp = a
    a = b
    b = temp
}
let arr = [5,2,3,8,1]
let n = arr.length
for(let i = 1; i< n; i++){ // 1,[0], 2[0,1], 3[0,1,2], 4[0,1,2,3]
    for(let j= i-1; j<=0; j--){
        if(arr[i]< arr[j]){
            swap(arr[i], arr[j])
        }
    }
}
console.log(arr)

// 3.归并排序
/** 归并排序是建立在归并操作上的一种有效、稳定的排序算法。该算法是采用分治法的一个
 * 非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，
 * 再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
 * 
 */

// 4.快速排序
/** 步骤
 * （1）首先设定一个分界值，通过该分界值将数组分成左右两部分
 * （2）将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。
 * （3）然后，左边和右边的数据，可以独立排序。对于左侧的数据分组，又可以取一个分界值。
 * 将该部分分成左右两部分，同样在左边房子较小值，右边放置较大值。右侧数组也可以做类似处理
 * （4）重复上述过程，
 * 
 */

// 5.冒泡排序
/** 思想：它重复地走访要排序的数列，一次比较两个元素。如果它们的顺序错误就把它们交换过来。
 * 走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的由来
 * 是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
 * 步骤：
 *  (1)比较相邻的元素，如果第一个比第二个大，就交换它们两个
 * （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该是最大的数
 * （3）针对所有的元素重复以上的步骤，除了最后一个
 * （4）重复步骤1~3，直到排序完成
 */


